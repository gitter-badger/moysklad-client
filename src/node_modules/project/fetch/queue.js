var sleep = require('project/sleep');

var Queue = function (options) {
    options = options || {};

    this.timeout = options.timeout || 250;
    this.parallelTaskCount = options.parallelTaskCount || 2;
    this.async = 'async' in options ? !!options.async : true;

    this._lastTaskExecTime = 0;
    this._tasksInProgress = 0;

    this._queue = []
};

Queue.prototype.addTask = function (task, cb) {
    if (!cb && this.async) {
        throw new Error('Queue.addTask: callback must be defined in async mode');
    }
    this._queue.push({action: task, cb: cb});
    return this._processQueueTask()
};

Queue.prototype._processQueueTask = function () {
    var that = this;
    if (this._tasksInProgress < this.parallelTaskCount && this._queue.length > 0) {
        this._tasksInProgress++;
        var task = this._queue.shift();

        var waitTime = 0;

        if (this._lastTaskExecTime !== 0) {
            var timePassSinceLastTask = (+new Date()) - this._lastTaskExecTime;
            waitTime = timePassSinceLastTask >= this.timeout
                ? 0 : this.timeout - timePassSinceLastTask;
        }

        that._lastTaskExecTime = (+new Date()) + waitTime;

        var processTask = function (tsk) {
            var result;
            tsk.action(function (err, data) {
                that._tasksInProgress--;
                if (tsk.cb) {
                    tsk.cb.apply(null, arguments);
                    that._processQueueTask()
                } else {
                    if (err) {
                        throw err;
                    } else {
                        result = data;
                    }
                }
            });
            return result;
        };

        return waitTime
            ? sleep(waitTime, this.async, processTask.bind(null, task))
            : processTask(task)
    }
};

module.exports = Queue;


